<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta
      name="viewport"
      content="initial-scale=1, maximum-scale=1,user-scalable=no"
    />
    <title>NaviGator</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet-control-search/3.0.1/css/bundle.css" />
    <link rel="stylesheet" type="text/css" href="style.css" />
    <script src="./algorithms.js" type="module"></script>
  </head>
  <body>
    <div id="map-container">
      <div id="map"></div>
      <div id="input-container">
        <div id="menu-toggle">Hide menu</div>
        <h2>NaviGator</h2>
        <section id="mainText">
          <label for="startLocation"> Starting Point:</label>
          <input type="text" id="startLocation" name="startLocation">
          <br />
          <label for="endLocation">Destination:</label>
          <input type="text" id="endLocation" name="endLocation" />
          <br />
          <input type="checkbox" id="option2" name="option2" value="option2" />
          <label for="option2">Breadth-First Search</label><br />
          <input type="checkbox" id="option3" name="option3" value="option3" />
          <label for="option3">Depth-First Search</label><br />
          <button id="calculate-route-btn" onclick="calculateRoute()"> Calculate Route </button>
        </section>
      </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.js"></script>
    
    <script>
      var map = L.map("map").setView([29.6413, -82.357], 13);
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        attribution:
          'Map data Â© <a href="https://openstreetmap.org">OpenStreetMap</a> contributors',
        maxZoom: 18,
      }).addTo(map);
      
      var markerLayer = L.layerGroup().addTo(map);
      
      const customIcon = L.icon({
        iconSize: [10, 10], // adjust the size of the marker here
        popupAnchor: [0, -10] // adjust the popup anchor to position it correctly
      });

      var startSelected = false;
      fetch('/airports.dat.txt')
        .then((response) => response.text())
        .then((data) => {
          const lines = data.trim().split("\n");
          const markers = [];

          // Loop through each line and extract the airport name, longitude, and latitude
          for (let i = 0; i < lines.length/2; i++) {
            const fields = lines[i].split(",");
            const name = fields[1].replace(/"/g, ""); // remove quotes from the name
            const longitude = parseFloat(fields[6]);
            const latitude = parseFloat(fields[7]);


            // Create a marker object for each airport
            if(!isNaN(longitude) && !isNaN(latitude)){
              const marker = L.marker([longitude,latitude]);
              marker.bindPopup(name);
              markers.push(marker);
              marker.on('click', function(e) {
                markerLayer.clearLayers();
                const popupContent = e.target.getPopup().getContent();
                if (startSelected == false)
                {
                  const starLoc = document.getElementById("startLocation");
                  starLoc.value = popupContent;
                  startSelected = true;
                } else
                {
                  const endLoc = document.getElementById("endLocation");
                  endLoc.value = popupContent;
                }
                var latlng = e.latlng;
              });

            }
          }

          // Add markers to map and only show when on screen
          map.on('moveend', function() {
            const bounds = map.getBounds();

            markers.forEach(function(marker) {
              const markerLatLng = marker.getLatLng();
              if (bounds.contains(markerLatLng)) {
                map.addLayer(marker);
              } else {
                map.removeLayer(marker);
              }
            });
          });
        });

        // Define the coordinates for the two markers
        var startLatLng = L.latLng(30.2358,-81.680603);
        var endLatLng = L.latLng(29.6900997162,-82.2717971802);

        // Create an array of LatLng points for the polyline
        var polylinePoints = [startLatLng, endLatLng];

        // Create the polyline object and add it to the map
        var polyline = L.polyline(polylinePoints, {color: 'red'}).addTo(map);
      

      var isContainerVisible = true;
      document.getElementById("menu-toggle").addEventListener("click", function() {
        var inputContainer = document.getElementById("input-container");
        var menuToggle = document.getElementById("menu-toggle");
        if (isContainerVisible) {
          inputContainer.style.left = "-500px";
          isContainerVisible = false;
          menuToggle.innerText = "Show menu";
        } else {
          inputContainer.style.left = "0px";
          isContainerVisible = true;
          menuToggle.innerText = "Hide menu";
        }
      });

      function calculateRoute()
      {
        console.log("Calculating");
        var starLoc = document.getElementById("startLocation");
        var endLoc = document.getElementById("endLocation");
        var bfsAlgo = false;
        var dfsAlgo = false;
        const bfsCheck = document.getElementById('option2');
        const dfsCheck = document.getElementById('option3');


        if(bfsCheck.checked)
        {
          bfsAlgo = true;
        }

        if(dfsCheck.checked)
        {
          dfsAlgo = true;
        }

        if (dfsAlgo || bfsAlgo)
        {
          // Create a graph
          const graph = {};
          fetch('/airports.dat.txt')
          .then((response) => response.text())
          .then((data) => {
            const lines = data.trim().split("\n");
            const markers = [];

            // Loop through each line and extract the airport name, longitude, and latitude
            for (let i = 0; i < lines.length/2; i++) {
              const line = lines[i].split(",");
              const code1 = line[3];
              const code2 = line[4];
              if (code1 && code2) {
                if (!graph[code1]) graph[code1] = [];
                if (!graph[code2]) graph[code2] = [];
                const distance = getDistance(line);
                graph[code1].push({ node: code2, distance });
                graph[code2].push({ node: code1, distance });
              }
              console.log("check");
            }

              // Get the distance between two airports based on their coordinates
            function getDistance(line) {
              const lat1 = parseFloat(line[6]);
              const lon1 = parseFloat(line[7]);
              const lat2 = parseFloat(line[10]);
              const lon2 = parseFloat(line[11]);
              const R = 6371; // Radius of the earth in km
              const dLat = deg2rad(lat2 - lat1); // deg2rad below
              const dLon = deg2rad(lon2 - lon1);
              const a =
                  Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                  Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
              const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
              const d = R * c; // Distance in km
              return d;
            }

            function deg2rad(deg) {
              return deg * (Math.PI / 180);
            }

            if (bfsAlgo)
            {
              console.log("BFS");
              var source = starLoc.value;
              var destination = endLoc.value;
              bfs(graph, source, destination);

              // Breadth-first search algorithm
              function bfs(graph, start, destination) {
              const queue = [{ node: start, path: [], distance: 0 }];
              const visited = new Set();
              while (queue.length > 0) {
                  const { node, path, distance } = queue.shift();
                  if (node === destination) {
                      return `${path.join(' -> ')} -> ${destination} (distance: ${distance.toFixed(2)} km)`;
                  }
                  visited.add(node);
                  for (const neighbor of graph[node] ? Array.from(graph[node]) : []) {
                      if (!visited.has(neighbor.node)) {
                          const newPath = [...path, node];
                          queue.push({ node: neighbor.node, path: newPath, distance: distance + neighbor.distance });
                      }
                  }
              }
              return 'No route found';
              }
            }

            if (dfsAlgo)
            {
              var source = starLoc.value;
              var destination = endLoc.value;
              console.log(`Data: ${dfs(graph, source, destination)}`);
              function dfs(graph, start, destination, visited = new Set(), path = [], distance = 0) {
                visited.add(start);
                path.push(start);
                if (start === destination) {
                    //return ${path.join(' -> ')} (distance: ${distance.toFixed(2)} km);
                    return path.join(' -> ') + ' (distance: ' + distance.toFixed(2) + ' km)';

                }
                for (const neighbor of graph[start]) {
                    if (!visited.has(neighbor.node)) {
                        const result = dfs(graph, neighbor.node, destination, visited, path, distance + neighbor.distance);
                        if (result) {
                            return result;
                        }
                    }
                }
                path.pop();
                return null;
              }
            }
          });      
        } 
      }
      
    </script>
  </head>
</html>
